/* Generated By:JJTree: Do not edit this line. OMatchStatement.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=true,NODE_PREFIX=O,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.orientechnologies.orient.core.sql.parser;

import com.orientechnologies.orient.core.command.OBasicCommandContext;
import com.orientechnologies.orient.core.command.OCommandContext;
import com.orientechnologies.orient.core.db.ODatabaseSession;
import com.orientechnologies.orient.core.db.record.OIdentifiable;
import com.orientechnologies.orient.core.exception.OCommandExecutionException;
import com.orientechnologies.orient.core.metadata.schema.OClass;
import com.orientechnologies.orient.core.metadata.schema.OSchema;
import com.orientechnologies.orient.core.record.impl.ODocument;
import com.orientechnologies.orient.core.sql.executor.OInternalExecutionPlan;
import com.orientechnologies.orient.core.sql.executor.OMatchExecutionPlanner;
import com.orientechnologies.orient.core.sql.executor.OResultSet;
import com.orientechnologies.orient.core.sql.executor.PatternEdge;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class OMatchStatement extends OStatement {
  static final String DEFAULT_ALIAS_PREFIX = "$ORIENT_DEFAULT_ALIAS_";

  public static final String KEYWORD_MATCH = "MATCH";
  // parsed data
  protected List<OMatchExpression> matchExpressions = new ArrayList<>();
  protected List<OMatchExpression> notMatchExpressions = new ArrayList<>();
  protected List<OExpression> returnItems = new ArrayList<>();
  protected List<OIdentifier> returnAliases = new ArrayList<>();
  protected List<ONestedProjection> returnNestedProjections = new ArrayList<>();
  protected boolean returnDistinct = false;
  protected OGroupBy groupBy;
  protected OOrderBy orderBy;
  protected OUnwind unwind;
  protected OSkip skip;
  protected OLimit limit;

  // post-parsing generated data
  protected Pattern pattern;

  // execution data
  private OCommandContext context;

  long threshold = 20;

  public List<ONestedProjection> getReturnNestedProjections() {
    return returnNestedProjections;
  }

  public void setReturnNestedProjections(List<ONestedProjection> returnNestedProjections) {
    this.returnNestedProjections = returnNestedProjections;
  }

  public void addMatchExpression(OMatchExpression exp) {
    this.matchExpressions.add(exp);
  }

  public void addNotMatchExpression(OMatchExpression exp) {
    this.notMatchExpressions.add(exp);
  }

  public void addReturnNestedProjection(ONestedProjection projection) {
    this.returnNestedProjections.add(projection);
  }

  public void addReturnItem(OExpression item) {
    this.returnItems.add(item);
  }

  public void addReturnAlias(OIdentifier alias) {
    this.returnAliases.add(alias);
  }

  public class MatchContext {
    int currentEdgeNumber = 0;

    Map<String, Iterable> candidates = new LinkedHashMap<String, Iterable>();
    Map<String, OIdentifiable> matched = new LinkedHashMap<String, OIdentifiable>();
    Map<PatternEdge, Boolean> matchedEdges = new IdentityHashMap<PatternEdge, Boolean>();

    public MatchContext copy(String alias, OIdentifiable value) {
      MatchContext result = new MatchContext();

      result.candidates.putAll(candidates);
      result.candidates.remove(alias);

      result.matched.putAll(matched);
      result.matched.put(alias, value);

      result.matchedEdges.putAll(matchedEdges);
      result.currentEdgeNumber = currentEdgeNumber;
      return result;
    }

    public ODocument toDoc() {
      ODocument doc = new ODocument();
      doc.fromMap((Map) matched);
      return doc;
    }
  }

  public OMatchStatement() {
    super(-1);
  }

  public OMatchStatement(int id) {
    super(id);
  }

  public OMatchStatement(OrientSql p, int id) {
    super(p, id);
  }

  @Override
  public OResultSet execute(
      ODatabaseSession db, Object[] args, OCommandContext parentCtx, boolean usePlanCache) {
    OBasicCommandContext ctx = new OBasicCommandContext(db);
    if (parentCtx != null) {
      ctx.setParentWithoutOverridingChild(parentCtx);
    }
    Map<Object, Object> params = new HashMap<>();
    if (args != null) {
      for (int i = 0; i < args.length; i++) {
        params.put(i, args[i]);
      }
    }
    ctx.setInputParameters(params);
    OInternalExecutionPlan executionPlan;
    if (usePlanCache) {
      executionPlan = createExecutionPlan(ctx, false);
    } else {
      executionPlan = createExecutionPlanNoCache(ctx, false);
    }

    return new OLocalResultSet(executionPlan, ctx);
  }

  @Override
  public OResultSet execute(
      ODatabaseSession db, Map params, OCommandContext parentCtx, boolean usePlanCache) {
    OBasicCommandContext ctx = new OBasicCommandContext(db);
    if (parentCtx != null) {
      ctx.setParentWithoutOverridingChild(parentCtx);
    }
    ctx.setInputParameters(params);
    OInternalExecutionPlan executionPlan;
    if (usePlanCache) {
      executionPlan = createExecutionPlan(ctx, false);
    } else {
      executionPlan = createExecutionPlanNoCache(ctx, false);
    }

    return new OLocalResultSet(executionPlan, ctx);
  }

  public OInternalExecutionPlan createExecutionPlan(OCommandContext ctx, boolean enableProfiling) {
    OMatchExecutionPlanner planner = new OMatchExecutionPlanner(this);
    OInternalExecutionPlan result = planner.createExecutionPlan(ctx, enableProfiling);
    result.setStatement(originalStatement);
    result.setGenericStatement(this.toGenericStatement());
    return result;
  }

  protected void buildPatterns() {
    assignDefaultAliases(this.matchExpressions);
    pattern = new Pattern();
    for (OMatchExpression expr : this.matchExpressions) {
      pattern.addExpression(expr);
    }

    Map<String, OWhereClause> aliasFilters = new LinkedHashMap<String, OWhereClause>();
    Map<String, String> aliasClasses = new LinkedHashMap<String, String>();
    for (OMatchExpression expr : this.matchExpressions) {
      addAliases(expr, aliasFilters, aliasClasses, context);
    }

    rebindFilters(aliasFilters);
  }

  /**
   * rebinds filter (where) conditions to alias nodes after optimization
   *
   * @param aliasFilters
   */
  private void rebindFilters(Map<String, OWhereClause> aliasFilters) {
    for (OMatchExpression expression : matchExpressions) {
      OWhereClause newFilter = aliasFilters.get(expression.origin.getAlias());
      expression.origin.setFilter(newFilter);

      for (OMatchPathItem item : expression.items) {
        newFilter = aliasFilters.get(item.filter.getAlias());
        item.filter.setFilter(newFilter);
      }
    }
  }

  /**
   * assigns default aliases to pattern nodes that do not have an explicit alias
   *
   * @param matchExpressions
   */
  private void assignDefaultAliases(List<OMatchExpression> matchExpressions) {
    int counter = 0;
    for (OMatchExpression expression : matchExpressions) {
      if (expression.origin.getAlias() == null) {
        expression.origin.setAlias(DEFAULT_ALIAS_PREFIX + (counter++));
      }

      for (OMatchPathItem item : expression.items) {
        if (item.filter == null) {
          item.filter = new OMatchFilter(-1);
        }
        if (item.filter.getAlias() == null) {
          item.filter.setAlias(DEFAULT_ALIAS_PREFIX + (counter++));
        }
      }
    }
  }

  public boolean returnsPathElements() {
    for (OExpression item : returnItems) {
      if (item.toString().equalsIgnoreCase("$pathElements")) {
        return true;
      }
    }
    return false;
  }

  public boolean returnsElements() {
    for (OExpression item : returnItems) {
      if (item.toString().equalsIgnoreCase("$elements")) {
        return true;
      }
    }
    return false;
  }

  public boolean returnsPatterns() {
    for (OExpression item : returnItems) {
      if (item.toString().equalsIgnoreCase("$patterns")) {
        return true;
      }
      if (item.toString().equalsIgnoreCase("$matches")) {
        return true;
      }
    }
    return false;
  }

  public boolean returnsPaths() {
    for (OExpression item : returnItems) {
      if (item.toString().equalsIgnoreCase("$paths")) {
        return true;
      }
    }
    return false;
  }

  private void addAliases(
      OMatchExpression expr,
      Map<String, OWhereClause> aliasFilters,
      Map<String, String> aliasClasses,
      OCommandContext context) {
    addAliases(expr.origin, aliasFilters, aliasClasses, context);
    for (OMatchPathItem item : expr.items) {
      if (item.filter != null) {
        addAliases(item.filter, aliasFilters, aliasClasses, context);
      }
    }
  }

  private void addAliases(
      OMatchFilter matchFilter,
      Map<String, OWhereClause> aliasFilters,
      Map<String, String> aliasClasses,
      OCommandContext context) {
    String alias = matchFilter.getAlias();
    OWhereClause filter = matchFilter.getFilter();
    if (alias != null) {
      if (filter != null && filter.baseExpression != null) {
        OWhereClause previousFilter = aliasFilters.get(alias);
        if (previousFilter == null) {
          previousFilter = new OWhereClause(-1);
          previousFilter.baseExpression = new OAndBlock(-1);
          aliasFilters.put(alias, previousFilter);
        }
        OAndBlock filterBlock = (OAndBlock) previousFilter.baseExpression;
        if (filter != null && filter.baseExpression != null) {
          filterBlock.subBlocks.add(filter.baseExpression);
        }
      }

      String clazz = matchFilter.getClassName(context);
      if (clazz != null) {
        String previousClass = aliasClasses.get(alias);
        if (previousClass == null) {
          aliasClasses.put(alias, clazz);
        } else {
          String lower = getLowerSubclass(clazz, previousClass, context);
          if (lower == null) {
            throw new OCommandExecutionException(
                "classes defined for alias "
                    + alias
                    + " ("
                    + clazz
                    + ", "
                    + previousClass
                    + ") are not in the same hierarchy");
          }
          aliasClasses.put(alias, lower);
        }
      }
    }
  }

  private String getLowerSubclass(String className1, String className2, OCommandContext ctx) {
    OSchema schema = ctx.getDatabase().getMetadata().getSchema();
    OClass class1 = schema.getClass(className1);
    OClass class2 = schema.getClass(className2);
    if (class1 == null) {
      throw new OCommandExecutionException("Class " + className1 + " not found in the schema");
    }
    if (class2 == null) {
      throw new OCommandExecutionException("Class " + className2 + " not found in the schema");
    }
    if (class1.isSubClassOf(class2)) {
      return class1.getName();
    }
    if (class2.isSubClassOf(class1)) {
      return class2.getName();
    }
    return null;
  }

  @Override
  public boolean isIdempotent() {
    return true;
  }

  public void toString(Map<Object, Object> params, StringBuilder builder) {
    builder.append(KEYWORD_MATCH);
    builder.append(" ");
    boolean first = true;
    for (OMatchExpression expr : this.matchExpressions) {
      if (!first) {
        builder.append(", ");
      }
      expr.toString(params, builder);
      first = false;
    }
    builder.append(" RETURN ");
    if (returnDistinct) {
      builder.append("DISTINCT ");
    }
    first = true;
    int i = 0;
    for (OExpression expr : this.returnItems) {
      if (!first) {
        builder.append(", ");
      }
      expr.toString(params, builder);
      if (returnNestedProjections != null
          && i < returnNestedProjections.size()
          && returnNestedProjections.get(i) != null) {
        returnNestedProjections.get(i).toString(params, builder);
      }
      if (returnAliases != null && i < returnAliases.size() && returnAliases.get(i) != null) {
        builder.append(" AS ");
        returnAliases.get(i).toString(params, builder);
      }
      i++;
      first = false;
    }
    if (groupBy != null) {
      builder.append(" ");
      groupBy.toString(params, builder);
    }
    if (orderBy != null) {
      builder.append(" ");
      orderBy.toString(params, builder);
    }
    if (unwind != null) {
      builder.append(" ");
      unwind.toString(params, builder);
    }
    if (skip != null) {
      builder.append(" ");
      skip.toString(params, builder);
    }
    if (limit != null) {
      builder.append(" ");
      limit.toString(params, builder);
    }
  }

  public void toGenericStatement(StringBuilder builder) {
    builder.append(KEYWORD_MATCH);
    builder.append(" ");
    boolean first = true;
    for (OMatchExpression expr : this.matchExpressions) {
      if (!first) {
        builder.append(", ");
      }
      expr.toGenericStatement(builder);
      first = false;
    }
    builder.append(" RETURN ");
    if (returnDistinct) {
      builder.append("DISTINCT ");
    }
    first = true;
    int i = 0;
    for (OExpression expr : this.returnItems) {
      if (!first) {
        builder.append(", ");
      }
      expr.toGenericStatement(builder);
      if (returnNestedProjections != null
          && i < returnNestedProjections.size()
          && returnNestedProjections.get(i) != null) {
        returnNestedProjections.get(i).toGenericStatement(builder);
      }
      if (returnAliases != null && i < returnAliases.size() && returnAliases.get(i) != null) {
        builder.append(" AS ");
        returnAliases.get(i).toGenericStatement(builder);
      }
      i++;
      first = false;
    }
    if (groupBy != null) {
      builder.append(" ");
      groupBy.toGenericStatement(builder);
    }
    if (orderBy != null) {
      builder.append(" ");
      orderBy.toGenericStatement(builder);
    }
    if (unwind != null) {
      builder.append(" ");
      unwind.toGenericStatement(builder);
    }
    if (skip != null) {
      builder.append(" ");
      skip.toGenericStatement(builder);
    }
    if (limit != null) {
      builder.append(" ");
      limit.toGenericStatement(builder);
    }
  }

  @Override
  public OMatchStatement copy() {
    OMatchStatement result = new OMatchStatement(-1);
    result.matchExpressions =
        matchExpressions == null
            ? null
            : matchExpressions.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    result.notMatchExpressions =
        notMatchExpressions == null
            ? null
            : notMatchExpressions.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    result.returnItems =
        returnItems == null
            ? null
            : returnItems.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    result.returnAliases =
        returnAliases == null
            ? null
            : returnAliases.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    result.returnNestedProjections =
        returnNestedProjections == null
            ? null
            : returnNestedProjections.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    result.groupBy = groupBy == null ? null : groupBy.copy();
    result.orderBy = orderBy == null ? null : orderBy.copy();
    result.unwind = unwind == null ? null : unwind.copy();
    result.skip = skip == null ? null : skip.copy();
    result.limit = limit == null ? null : limit.copy();
    result.returnDistinct = this.returnDistinct;
    result.buildPatterns();
    return result;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    OMatchStatement that = (OMatchStatement) o;

    if (matchExpressions != null
        ? !matchExpressions.equals(that.matchExpressions)
        : that.matchExpressions != null) return false;
    if (notMatchExpressions != null
        ? !notMatchExpressions.equals(that.notMatchExpressions)
        : that.notMatchExpressions != null) return false;
    if (returnItems != null ? !returnItems.equals(that.returnItems) : that.returnItems != null)
      return false;
    if (returnAliases != null
        ? !returnAliases.equals(that.returnAliases)
        : that.returnAliases != null) return false;
    if (returnNestedProjections != null
        ? !returnNestedProjections.equals(that.returnNestedProjections)
        : that.returnNestedProjections != null) return false;
    if (groupBy != null ? !groupBy.equals(that.groupBy) : that.groupBy != null) return false;
    if (orderBy != null ? !orderBy.equals(that.orderBy) : that.orderBy != null) return false;
    if (unwind != null ? !unwind.equals(that.unwind) : that.unwind != null) return false;
    if (skip != null ? !skip.equals(that.skip) : that.skip != null) return false;
    if (limit != null ? !limit.equals(that.limit) : that.limit != null) return false;

    if (returnDistinct != that.returnDistinct) return false;

    return true;
  }

  @Override
  public int hashCode() {
    int result = matchExpressions != null ? matchExpressions.hashCode() : 0;
    result = 31 * result + (notMatchExpressions != null ? notMatchExpressions.hashCode() : 0);
    result = 31 * result + (returnItems != null ? returnItems.hashCode() : 0);
    result = 31 * result + (returnAliases != null ? returnAliases.hashCode() : 0);
    result =
        31 * result + (returnNestedProjections != null ? returnNestedProjections.hashCode() : 0);
    result = 31 * result + (groupBy != null ? groupBy.hashCode() : 0);
    result = 31 * result + (orderBy != null ? orderBy.hashCode() : 0);
    result = 31 * result + (unwind != null ? unwind.hashCode() : 0);
    result = 31 * result + (skip != null ? skip.hashCode() : 0);
    result = 31 * result + (limit != null ? limit.hashCode() : 0);
    return result;
  }

  public OLimit getLimit() {
    return limit;
  }

  public void setLimit(OLimit limit) {
    this.limit = limit;
  }

  public List<OIdentifier> getReturnAliases() {
    return returnAliases;
  }

  public void setReturnAliases(List<OIdentifier> returnAliases) {
    this.returnAliases = returnAliases;
  }

  public List<OExpression> getReturnItems() {
    return returnItems;
  }

  public void setReturnItems(List<OExpression> returnItems) {
    this.returnItems = returnItems;
  }

  public List<OMatchExpression> getMatchExpressions() {
    return matchExpressions;
  }

  public void setMatchExpressions(List<OMatchExpression> matchExpressions) {
    this.matchExpressions = matchExpressions;
  }

  public List<OMatchExpression> getNotMatchExpressions() {
    return notMatchExpressions;
  }

  public void setNotMatchExpressions(List<OMatchExpression> notMatchExpressions) {
    this.notMatchExpressions = notMatchExpressions;
  }

  public boolean isReturnDistinct() {
    return returnDistinct;
  }

  public void setReturnDistinct(boolean returnDistinct) {
    this.returnDistinct = returnDistinct;
  }

  public OOrderBy getOrderBy() {
    return orderBy;
  }

  public void setOrderBy(OOrderBy orderBy) {
    this.orderBy = orderBy;
  }

  public OGroupBy getGroupBy() {
    return groupBy;
  }

  public void setGroupBy(OGroupBy groupBy) {
    this.groupBy = groupBy;
  }

  public OUnwind getUnwind() {
    return unwind;
  }

  public void setUnwind(OUnwind unwind) {
    this.unwind = unwind;
  }

  public OSkip getSkip() {
    return skip;
  }

  public void setSkip(OSkip skip) {
    this.skip = skip;
  }

  @Override
  public boolean refersToParent() {
    // TODO check this!
    return false;
  }
}
/* JavaCC - OriginalChecksum=6ff0afbe9d31f08b72159fcf24070c9f (do not edit this line) */
